{"ast":null,"code":"export function getSurroundingCellIndex(row, column) {\n  return [[row - 1, column - 1], [row - 1, column], [row - 1, column + 1], [row, column - 1], [row, column + 1], [row + 1, column - 1], [row + 1, column], [row + 1, column + 1]];\n}\nexport function isCell(board, row, column) {\n  if (row >= 0 && row < board.length && column >= 0 && column < board[0].length) {\n    return true;\n  }\n\n  return false;\n}\nexport function doSomethingToAdjacentCells(board, row, column, func) {\n  const newBoard = JSON.parse(JSON.stringify(board));\n  const surroundingCellIndex = getSurroundingCellIndex(row, column);\n\n  for (let [newRow, newColumn] of surroundingCellIndex) {\n    if (isCell(newBoard, newRow, newColumn)) func(newBoard[newRow][newColumn]);\n  }\n\n  return newBoard;\n}\n;\nexport function referenceToAdjacentCells(originalBoard, row, column) {\n  const adjacentCells = [];\n  const surroundingCellIndex = getSurroundingCellIndex(row, column);\n\n  for (let [newRow, newColumn] of surroundingCellIndex) {\n    if (isCell(originalBoard, newRow, newColumn)) {\n      adjacentCells.push({\n        cell: originalBoard[newRow][newColumn],\n        row: newRow,\n        column: newColumn\n      });\n    }\n  }\n\n  return adjacentCells;\n}","map":{"version":3,"sources":["/home/lauralimon/challengs/MINESWEEPIN/src/utility/utility.js"],"names":["getSurroundingCellIndex","row","column","isCell","board","length","doSomethingToAdjacentCells","func","newBoard","JSON","parse","stringify","surroundingCellIndex","newRow","newColumn","referenceToAdjacentCells","originalBoard","adjacentCells","push","cell"],"mappings":"AAAA,OAAO,SAASA,uBAAT,CAAiCC,GAAjC,EAAsCC,MAAtC,EAA8C;AACnD,SAAO,CACL,CAACD,GAAG,GAAG,CAAP,EAAUC,MAAM,GAAG,CAAnB,CADK,EAEL,CAACD,GAAG,GAAG,CAAP,EAAUC,MAAV,CAFK,EAGL,CAACD,GAAG,GAAG,CAAP,EAAUC,MAAM,GAAG,CAAnB,CAHK,EAIL,CAACD,GAAD,EAAMC,MAAM,GAAG,CAAf,CAJK,EAKL,CAACD,GAAD,EAAMC,MAAM,GAAG,CAAf,CALK,EAML,CAACD,GAAG,GAAG,CAAP,EAAUC,MAAM,GAAE,CAAlB,CANK,EAOL,CAACD,GAAG,GAAG,CAAP,EAAUC,MAAV,CAPK,EAQL,CAACD,GAAG,GAAG,CAAP,EAAUC,MAAM,GAAG,CAAnB,CARK,CAAP;AAUD;AAED,OAAO,SAASC,MAAT,CAAgBC,KAAhB,EAAuBH,GAAvB,EAA4BC,MAA5B,EAAoC;AACzC,MAAGD,GAAG,IAAI,CAAP,IAAYA,GAAG,GAAGG,KAAK,CAACC,MAAxB,IAAkCH,MAAM,IAAG,CAA3C,IAAgDA,MAAM,GAAGE,KAAK,CAAC,CAAD,CAAL,CAASC,MAArE,EAA6E;AAC3E,WAAO,IAAP;AACD;;AAED,SAAO,KAAP;AACD;AAED,OAAO,SAASC,0BAAT,CAAoCF,KAApC,EAA2CH,GAA3C,EAAgDC,MAAhD,EAAwDK,IAAxD,EAA8D;AACnE,QAAMC,QAAQ,GAAGC,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,SAAL,CAAeP,KAAf,CAAX,CAAjB;AACA,QAAMQ,oBAAoB,GAAGZ,uBAAuB,CAACC,GAAD,EAAMC,MAAN,CAApD;;AAEA,OAAI,IAAI,CAACW,MAAD,EAASC,SAAT,CAAR,IAA+BF,oBAA/B,EAAqD;AACnD,QAAIT,MAAM,CAACK,QAAD,EAAWK,MAAX,EAAmBC,SAAnB,CAAV,EAAyCP,IAAI,CAACC,QAAQ,CAACK,MAAD,CAAR,CAAiBC,SAAjB,CAAD,CAAJ;AAC1C;;AAED,SAAON,QAAP;AACD;AAAA;AAED,OAAO,SAASO,wBAAT,CAAkCC,aAAlC,EAAiDf,GAAjD,EAAsDC,MAAtD,EAA8D;AACnE,QAAMe,aAAa,GAAG,EAAtB;AAEA,QAAML,oBAAoB,GAAGZ,uBAAuB,CAACC,GAAD,EAAMC,MAAN,CAApD;;AAEA,OAAI,IAAI,CAACW,MAAD,EAASC,SAAT,CAAR,IAA+BF,oBAA/B,EAAqD;AAEnD,QAAIT,MAAM,CAACa,aAAD,EAAgBH,MAAhB,EAAwBC,SAAxB,CAAV,EAA8C;AAC5CG,MAAAA,aAAa,CAACC,IAAd,CAAmB;AACjBC,QAAAA,IAAI,EAAEH,aAAa,CAACH,MAAD,CAAb,CAAsBC,SAAtB,CADW;AAEjBb,QAAAA,GAAG,EAAEY,MAFY;AAGjBX,QAAAA,MAAM,EAAEY;AAHS,OAAnB;AAKD;AACF;;AAED,SAAOG,aAAP;AACD","sourcesContent":["export function getSurroundingCellIndex(row, column) {\n  return [\n    [row - 1, column - 1],\n    [row - 1, column],\n    [row - 1, column + 1],\n    [row, column - 1],\n    [row, column + 1],\n    [row + 1, column -1],\n    [row + 1, column],\n    [row + 1, column + 1],\n  ];\n}\n\nexport function isCell(board, row, column) {\n  if(row >= 0 && row < board.length && column >=0 && column < board[0].length) {\n    return true;\n  }\n\n  return false;\n}\n\nexport function doSomethingToAdjacentCells(board, row, column, func) {\n  const newBoard = JSON.parse(JSON.stringify(board));\n  const surroundingCellIndex = getSurroundingCellIndex(row, column);\n\n  for(let [newRow, newColumn] of surroundingCellIndex) {\n    if (isCell(newBoard, newRow, newColumn)) func(newBoard[newRow][newColumn]);\n  }\n\n  return newBoard;\n};\n\nexport function referenceToAdjacentCells(originalBoard, row, column) {\n  const adjacentCells = [];\n\n  const surroundingCellIndex = getSurroundingCellIndex(row, column);\n\n  for(let [newRow, newColumn] of surroundingCellIndex) {\n\n    if (isCell(originalBoard, newRow, newColumn)) {\n      adjacentCells.push({\n        cell: originalBoard[newRow][newColumn],\n        row: newRow,\n        column: newColumn,\n      });\n    }\n  }\n\n  return adjacentCells;\n}"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"export function getSurroundingCellIndex(positionX, positionY) {\n  return [[positionX - 1, positionY - 1], [positionX - 1, positionY], [positionX - 1, positionY + 1], [positionX, positionY - 1], [positionX, positionY + 1], [positionX + 1, positionY - 1], [positionX + 1, positionY], [positionX + 1, positionY + 1]];\n}\nexport function isCell(board, row, column) {\n  if (row >= 0 && row < board.length && column >= 0 && column < board[0].length) {\n    return true;\n  }\n\n  return false;\n}\nexport function doSomethingToAdjacentCells(board, row, column, func) {\n  const newBoard = JSON.parse(JSON.stringify(board));\n  const surroundingCellIndex = getSurroundingCellIndex(row, column);\n\n  for (let [newRow, newColumn] of surroundingCellIndex) {\n    if (isCell(newBoard, newRow, newColumn)) func(newBoard[newRow][newColumn]);\n  }\n\n  return newBoard;\n}\n;\nexport function referenceToAdjacentCells(originalBoard, row, column) {\n  const adjacentCells = [];\n  const surroundingCellIndex = getSurroundingCellIndex(row, column);\n\n  for (let [newRow, newColumn] of surroundingCellIndex) {\n    if (isCell(originalBoard, newRow, newColumn)) {\n      adjacentCells.push({\n        cell: originalBoard[newRow][newColumn],\n        row: newRow,\n        column: newColumn\n      });\n    }\n  }\n\n  return adjacentCells;\n}","map":{"version":3,"sources":["/home/lauralimon/challengs/MINESWEEPIN/src/utility/utility.js"],"names":["getSurroundingCellIndex","positionX","positionY","isCell","board","row","column","length","doSomethingToAdjacentCells","func","newBoard","JSON","parse","stringify","surroundingCellIndex","newRow","newColumn","referenceToAdjacentCells","originalBoard","adjacentCells","push","cell"],"mappings":"AAAA,OAAO,SAASA,uBAAT,CAAiCC,SAAjC,EAA4CC,SAA5C,EAAuD;AAC5D,SAAO,CACL,CAACD,SAAS,GAAG,CAAb,EAAgBC,SAAS,GAAG,CAA5B,CADK,EAEL,CAACD,SAAS,GAAG,CAAb,EAAgBC,SAAhB,CAFK,EAGL,CAACD,SAAS,GAAG,CAAb,EAAgBC,SAAS,GAAG,CAA5B,CAHK,EAIL,CAACD,SAAD,EAAYC,SAAS,GAAG,CAAxB,CAJK,EAKL,CAACD,SAAD,EAAYC,SAAS,GAAG,CAAxB,CALK,EAML,CAACD,SAAS,GAAG,CAAb,EAAgBC,SAAS,GAAG,CAA5B,CANK,EAOL,CAACD,SAAS,GAAG,CAAb,EAAgBC,SAAhB,CAPK,EAQL,CAACD,SAAS,GAAG,CAAb,EAAgBC,SAAS,GAAG,CAA5B,CARK,CAAP;AAUD;AAED,OAAO,SAASC,MAAT,CAAgBC,KAAhB,EAAuBC,GAAvB,EAA4BC,MAA5B,EAAoC;AACzC,MAAID,GAAG,IAAI,CAAP,IAAYA,GAAG,GAAGD,KAAK,CAACG,MAAxB,IAAkCD,MAAM,IAAI,CAA5C,IAAiDA,MAAM,GAAGF,KAAK,CAAC,CAAD,CAAL,CAASG,MAAvE,EAA+E;AAC7E,WAAO,IAAP;AACD;;AAED,SAAO,KAAP;AACD;AAED,OAAO,SAASC,0BAAT,CAAoCJ,KAApC,EAA2CC,GAA3C,EAAgDC,MAAhD,EAAwDG,IAAxD,EAA8D;AACnE,QAAMC,QAAQ,GAAGC,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,SAAL,CAAeT,KAAf,CAAX,CAAjB;AACA,QAAMU,oBAAoB,GAAGd,uBAAuB,CAACK,GAAD,EAAMC,MAAN,CAApD;;AAEA,OAAK,IAAI,CAACS,MAAD,EAASC,SAAT,CAAT,IAAgCF,oBAAhC,EAAsD;AACpD,QAAIX,MAAM,CAACO,QAAD,EAAWK,MAAX,EAAmBC,SAAnB,CAAV,EAAyCP,IAAI,CAACC,QAAQ,CAACK,MAAD,CAAR,CAAiBC,SAAjB,CAAD,CAAJ;AAC1C;;AAED,SAAON,QAAP;AACD;AAAA;AAED,OAAO,SAASO,wBAAT,CAAkCC,aAAlC,EAAiDb,GAAjD,EAAsDC,MAAtD,EAA8D;AACnE,QAAMa,aAAa,GAAG,EAAtB;AAEA,QAAML,oBAAoB,GAAGd,uBAAuB,CAACK,GAAD,EAAMC,MAAN,CAApD;;AAEA,OAAK,IAAI,CAACS,MAAD,EAASC,SAAT,CAAT,IAAgCF,oBAAhC,EAAsD;AAEpD,QAAIX,MAAM,CAACe,aAAD,EAAgBH,MAAhB,EAAwBC,SAAxB,CAAV,EAA8C;AAC5CG,MAAAA,aAAa,CAACC,IAAd,CAAmB;AACjBC,QAAAA,IAAI,EAAEH,aAAa,CAACH,MAAD,CAAb,CAAsBC,SAAtB,CADW;AAEjBX,QAAAA,GAAG,EAAEU,MAFY;AAGjBT,QAAAA,MAAM,EAAEU;AAHS,OAAnB;AAKD;AACF;;AAED,SAAOG,aAAP;AACD","sourcesContent":["export function getSurroundingCellIndex(positionX, positionY) {\n  return [\n    [positionX - 1, positionY - 1],\n    [positionX - 1, positionY],\n    [positionX - 1, positionY + 1],\n    [positionX, positionY - 1],\n    [positionX, positionY + 1],\n    [positionX + 1, positionY - 1],\n    [positionX + 1, positionY],\n    [positionX + 1, positionY + 1],\n  ];\n}\n\nexport function isCell(board, row, column) {\n  if (row >= 0 && row < board.length && column >= 0 && column < board[0].length) {\n    return true;\n  }\n\n  return false;\n}\n\nexport function doSomethingToAdjacentCells(board, row, column, func) {\n  const newBoard = JSON.parse(JSON.stringify(board));\n  const surroundingCellIndex = getSurroundingCellIndex(row, column);\n\n  for (let [newRow, newColumn] of surroundingCellIndex) {\n    if (isCell(newBoard, newRow, newColumn)) func(newBoard[newRow][newColumn]);\n  }\n\n  return newBoard;\n};\n\nexport function referenceToAdjacentCells(originalBoard, row, column) {\n  const adjacentCells = [];\n\n  const surroundingCellIndex = getSurroundingCellIndex(row, column);\n\n  for (let [newRow, newColumn] of surroundingCellIndex) {\n\n    if (isCell(originalBoard, newRow, newColumn)) {\n      adjacentCells.push({\n        cell: originalBoard[newRow][newColumn],\n        row: newRow,\n        column: newColumn,\n      });\n    }\n  }\n\n  return adjacentCells;\n}"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"export function getNeighborsPosition(positionX, positionY) {\n  //getSurroundingCellIndex\n  return [[positionX - 1, positionY - 1], [positionX - 1, positionY], [positionX - 1, positionY + 1], [positionX, positionY - 1], [positionX, positionY + 1], [positionX + 1, positionY - 1], [positionX + 1, positionY], [positionX + 1, positionY + 1]];\n}\nexport function getNeighborsStatus(originalBoard, positionX, positionY) {\n  //referenceToAdjacentCells\n  const neighbors = [];\n  const neighborsPosition = getNeighborsPosition(positionX, positionY);\n\n  for (let [newPositionX, newPositionY] of neighborsPosition) {\n    if (isCell(originalBoard, newPositionX, newPositionY)) {\n      neighbors.push({\n        cell: originalBoard[newPositionX][newPositionY],\n        row: newPositionX,\n        //ojooooooooooooooooo\n        column: newPositionY //ojoooooooooooooooo\n\n      });\n    }\n  }\n\n  return neighbors;\n}\nexport function isCell(board, row, column) {\n  if (row >= 0 && row < board.length && column >= 0 && column < board[0].length) {\n    return true;\n  }\n\n  return false;\n}\nexport function doSomethingToAdjacentCells(board, row, column, func) {\n  const newBoard = JSON.parse(JSON.stringify(board));\n  const surroundingCellIndex = getNeighborsPosition(row, column);\n\n  for (let [newRow, newColumn] of surroundingCellIndex) {\n    if (isCell(newBoard, newRow, newColumn)) func(newBoard[newRow][newColumn]);\n  }\n\n  return newBoard;\n}\n;","map":{"version":3,"sources":["/home/lauralimon/challengs/Minesweeper/src/utility/utility.js"],"names":["getNeighborsPosition","positionX","positionY","getNeighborsStatus","originalBoard","neighbors","neighborsPosition","newPositionX","newPositionY","isCell","push","cell","row","column","board","length","doSomethingToAdjacentCells","func","newBoard","JSON","parse","stringify","surroundingCellIndex","newRow","newColumn"],"mappings":"AAAA,OAAO,SAASA,oBAAT,CAA8BC,SAA9B,EAAyCC,SAAzC,EAAoD;AAAE;AAC3D,SAAO,CACL,CAACD,SAAS,GAAG,CAAb,EAAgBC,SAAS,GAAG,CAA5B,CADK,EAEL,CAACD,SAAS,GAAG,CAAb,EAAgBC,SAAhB,CAFK,EAGL,CAACD,SAAS,GAAG,CAAb,EAAgBC,SAAS,GAAG,CAA5B,CAHK,EAIL,CAACD,SAAD,EAAYC,SAAS,GAAG,CAAxB,CAJK,EAKL,CAACD,SAAD,EAAYC,SAAS,GAAG,CAAxB,CALK,EAML,CAACD,SAAS,GAAG,CAAb,EAAgBC,SAAS,GAAG,CAA5B,CANK,EAOL,CAACD,SAAS,GAAG,CAAb,EAAgBC,SAAhB,CAPK,EAQL,CAACD,SAAS,GAAG,CAAb,EAAgBC,SAAS,GAAG,CAA5B,CARK,CAAP;AAUD;AAED,OAAO,SAASC,kBAAT,CAA4BC,aAA5B,EAA2CH,SAA3C,EAAsDC,SAAtD,EAAiE;AAAE;AACxE,QAAMG,SAAS,GAAG,EAAlB;AAEA,QAAMC,iBAAiB,GAAGN,oBAAoB,CAACC,SAAD,EAAYC,SAAZ,CAA9C;;AAEA,OAAK,IAAI,CAACK,YAAD,EAAeC,YAAf,CAAT,IAAyCF,iBAAzC,EAA4D;AAE1D,QAAIG,MAAM,CAACL,aAAD,EAAgBG,YAAhB,EAA8BC,YAA9B,CAAV,EAAuD;AACrDH,MAAAA,SAAS,CAACK,IAAV,CAAe;AACbC,QAAAA,IAAI,EAAEP,aAAa,CAACG,YAAD,CAAb,CAA4BC,YAA5B,CADO;AAEbI,QAAAA,GAAG,EAAEL,YAFQ;AAEM;AACnBM,QAAAA,MAAM,EAAEL,YAHK,CAGS;;AAHT,OAAf;AAKD;AACF;;AAED,SAAOH,SAAP;AACD;AAWD,OAAO,SAASI,MAAT,CAAgBK,KAAhB,EAAuBF,GAAvB,EAA4BC,MAA5B,EAAoC;AACzC,MAAID,GAAG,IAAI,CAAP,IAAYA,GAAG,GAAGE,KAAK,CAACC,MAAxB,IAAkCF,MAAM,IAAI,CAA5C,IAAiDA,MAAM,GAAGC,KAAK,CAAC,CAAD,CAAL,CAASC,MAAvE,EAA+E;AAC7E,WAAO,IAAP;AACD;;AACD,SAAO,KAAP;AACD;AAOD,OAAO,SAASC,0BAAT,CAAoCF,KAApC,EAA2CF,GAA3C,EAAgDC,MAAhD,EAAwDI,IAAxD,EAA8D;AACnE,QAAMC,QAAQ,GAAGC,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,SAAL,CAAeP,KAAf,CAAX,CAAjB;AACA,QAAMQ,oBAAoB,GAAGtB,oBAAoB,CAACY,GAAD,EAAMC,MAAN,CAAjD;;AAEA,OAAK,IAAI,CAACU,MAAD,EAASC,SAAT,CAAT,IAAgCF,oBAAhC,EAAsD;AACpD,QAAIb,MAAM,CAACS,QAAD,EAAWK,MAAX,EAAmBC,SAAnB,CAAV,EAAyCP,IAAI,CAACC,QAAQ,CAACK,MAAD,CAAR,CAAiBC,SAAjB,CAAD,CAAJ;AAC1C;;AAED,SAAON,QAAP;AACD;AAAA","sourcesContent":["export function getNeighborsPosition(positionX, positionY) { //getSurroundingCellIndex\n  return [\n    [positionX - 1, positionY - 1],\n    [positionX - 1, positionY],\n    [positionX - 1, positionY + 1],\n    [positionX, positionY - 1],\n    [positionX, positionY + 1],\n    [positionX + 1, positionY - 1],\n    [positionX + 1, positionY],\n    [positionX + 1, positionY + 1],\n  ];\n}\n\nexport function getNeighborsStatus(originalBoard, positionX, positionY) { //referenceToAdjacentCells\n  const neighbors = [];\n\n  const neighborsPosition = getNeighborsPosition(positionX, positionY);\n\n  for (let [newPositionX, newPositionY] of neighborsPosition) {\n\n    if (isCell(originalBoard, newPositionX, newPositionY)) {\n      neighbors.push({\n        cell: originalBoard[newPositionX][newPositionY],\n        row: newPositionX, //ojooooooooooooooooo\n        column: newPositionY, //ojoooooooooooooooo\n      });\n    }\n  }\n\n  return neighbors;\n}\n\n\n\n\n\n\n\n\n\n\nexport function isCell(board, row, column) {\n  if (row >= 0 && row < board.length && column >= 0 && column < board[0].length) {\n    return true;\n  }\n  return false;\n}\n\n\n\n\n\n\nexport function doSomethingToAdjacentCells(board, row, column, func) {\n  const newBoard = JSON.parse(JSON.stringify(board));\n  const surroundingCellIndex = getNeighborsPosition(row, column);\n\n  for (let [newRow, newColumn] of surroundingCellIndex) {\n    if (isCell(newBoard, newRow, newColumn)) func(newBoard[newRow][newColumn]);\n  }\n\n  return newBoard;\n};\n\n"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import { InjectMineEnum } from '../constants/gameConstants'; //import { BoardActions } from '../actions/BoardActions';\n\nimport actionsName from \"../actions/actionsName\";\nimport { getNeighborsStatus, getNeighborsPosition } from '../utility/utility';\nexport function boardReducer(state, {\n  type,\n  payload\n}) {\n  switch (type) {\n    case actionsName.CREATE_BLANK_BOARD:\n      return { ...state,\n        gameOver: false,\n        winner: false,\n        isStarted: false,\n        hiddenMines: state.level.totalMines,\n        board: setBlankBoard(state.level)\n      };\n\n    case actionsName.CREATE_STARTED_GAME_BOARD:\n      return { ...state,\n        hiddenMines: payload.level.totalMines,\n        board: seedMinesAndNumbers(state.board, payload.level, payload.positionX, payload.positionY),\n        isStarted: true\n      };\n\n    case actionsName.OPEN_CELL:\n      return { ...state,\n        board: openCell(state.board, payload.positionX, payload.positionY),\n        winner: didWin(openCell(state.board, payload.positionX, payload.positionY))\n      };\n    // case actionsName.DOUBLE_CLICK_CELL:\n    //   return {\n    //     ...state,\n    //     board: uncoverAdjacentCells(state.board, payload.row, payload.column),\n    //     winner: didWin(uncoverAdjacentCells(state.board, payload.row, payload.column)),\n    //   };\n\n    case actionsName.RIGHT_CLICK_CELL:\n      return { ...state,\n        hiddenMines: recalculateHiddenMines(state.board, payload.positionX, payload.positionY, state.hiddenMines),\n        board: toggleFlagCell(state.board, payload.positionX, payload.positionY),\n        winner: didWin(toggleFlagCell(state.board, payload.positionX, payload.positionY))\n      };\n\n    case actionsName.CHANGE_LEVEL:\n      return { ...state,\n        gameOver: false,\n        winner: false,\n        isStarted: false,\n        level: payload.level,\n        hiddenMines: payload.level.totalMines,\n        board: setBlankBoard(payload.level)\n      };\n\n    case actionsName.GAME_OVER:\n      return { ...state,\n        gameOver: true\n      };\n\n    default:\n      throw new Error('No matching action type in reducer');\n  }\n}\n\nfunction setBlankBoard({\n  rows,\n  columns\n}) {\n  return Array.from(Array(rows), () => new Array(columns).fill({\n    hasMine: false,\n    isOpen: false,\n    countMinesAround: 0,\n    hasFlag: false\n  }));\n}\n\nfunction seedMinesAndNumbers(board, level, positionX, positionY) {\n  let boardWithSeedMines = seedMine(board, level.totalMines, positionX, positionY);\n  return seedNumber(boardWithSeedMines); //, positionX, positionY\n}\n\nfunction seedMine(blankBoard, numMineToSeed, positionX, positionY) {\n  let totalSeedMines = 0; //numInjectedMines\n\n  let tempBoard = JSON.parse(JSON.stringify(blankBoard));\n  let rowIndex = 0;\n  const neighborsPosition = getNeighborsPosition(positionX, positionY).map(index => JSON.stringify(index));\n\n  while (totalSeedMines < numMineToSeed) {\n    for (let i = 0; i < blankBoard[rowIndex].length; i++) {\n      if (totalSeedMines === numMineToSeed) break;\n      if (rowIndex === positionX && i === positionY) continue;\n      if (neighborsPosition.includes(JSON.stringify([rowIndex, i]))) continue;\n      const luckyNumber = Math.floor(Math.random() * Math.floor(10));\n\n      if (luckyNumber === 1 && tempBoard[rowIndex][i].hasMine === false) {\n        tempBoard[rowIndex][i].hasMine = true;\n        totalSeedMines++;\n      }\n    }\n\n    ;\n    if (rowIndex === blankBoard.length - 1) rowIndex = 0;else rowIndex++;\n  }\n\n  return tempBoard;\n}\n\nfunction seedNumber(prevBoard) {\n  for (let i = 0; i < prevBoard.length; i++) {\n    for (let j = 0; j < prevBoard[i].length; j++) {\n      const neighborsStatus = getNeighborsStatus(prevBoard, i, j);\n      let minesAround = 0;\n      neighborsStatus.forEach(neighbor => {\n        //, row, column\n        if (neighbor.cell.hasMine) minesAround++;\n      });\n      prevBoard[i][j].countMinesAround = minesAround;\n    }\n  }\n\n  return prevBoard;\n}\n\n;\n\nfunction openCell(originalBoard, positionX, positionY) {\n  const newBoard = JSON.parse(JSON.stringify(originalBoard));\n  newBoard[positionX][positionY].isOpen = true;\n\n  if (newBoard[positionX][positionY].countMinesAround === 0 && !newBoard[positionX][positionY].hasMine) {\n    return openNeighbors(newBoard, positionX, positionY);\n  }\n\n  return newBoard;\n}\n\nfunction openNeighbors(originalBoard, row, column) {\n  console.log(\"staaaaack\", originalBoard[row][column]);\n  const memo = {};\n  const stack = [{\n    cell: originalBoard[row][column],\n    row,\n    column\n  }]; // console.log(\"staaaaack\", stack)\n\n  while (stack.length > 0) {\n    const centerCell = stack.pop();\n    const surroundingCells = getNeighborsStatus(originalBoard, centerCell.row, centerCell.column);\n    const flagsInAdjacentCells = surroundingCells.reduce((acc, currCell) => {\n      if (currCell.cell.hasFlag) return acc + 1;\n      return acc;\n    }, 0);\n    if (flagsInAdjacentCells < centerCell.cell.countMinesAround) return originalBoard;\n\n    for (let cell of surroundingCells) {\n      if (memo[`${cell.row}-${cell.column}`]) continue;else {\n        memo[`${cell.row}-${cell.column}`] = true;\n      }\n      cell.cell.isOpen = cell.cell.hasFlag ? false : true;\n\n      if (cell.cell && !cell.cell.countMinesAround && !cell.cell.hasMine) {\n        stack.push(cell);\n      }\n    }\n  }\n\n  return originalBoard;\n}\n\n;\n\nfunction recalculateHiddenMines(board, row, column, hiddenMines) {\n  return board[row][column].hasFlag ? hiddenMines + 1 : hiddenMines - 1;\n} // function uncoverCell(originalBoard, positionX, positionY) {\n//   const newBoard = JSON.parse(JSON.stringify(originalBoard));\n//   newBoard[positionX][positionY].isOpen = true;\n//   if (newBoard[positionX][positionY].countMinesAround === 0 && !newBoard[positionX][positionY].hasMine) {\n//     return uncoverAdjacentCells(newBoard, positionX, positionY);\n//   }\n//   return newBoard;\n// }\n\n\nfunction toggleFlagCell(originalBoard, row, column) {\n  const newBoard = JSON.parse(JSON.stringify(originalBoard));\n  newBoard[row][column].hasFlag = !newBoard[row][column].hasFlag;\n  return newBoard;\n}\n\nfunction didWin(board) {\n  for (let i = 0; i < board.length; i++) {\n    for (let j = 0; j < board[0].length; j++) {\n      if (!board[i][j].hasMine && !board[i][j].isOpen) {\n        return false;\n      }\n\n      if (!board[i][j].hasMine && board[i][j].hasFlag) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}","map":{"version":3,"sources":["/home/lauralimon/challengs/MINESWEEPIN/src/reducers/boardReducer.js"],"names":["InjectMineEnum","actionsName","getNeighborsStatus","getNeighborsPosition","boardReducer","state","type","payload","CREATE_BLANK_BOARD","gameOver","winner","isStarted","hiddenMines","level","totalMines","board","setBlankBoard","CREATE_STARTED_GAME_BOARD","seedMinesAndNumbers","positionX","positionY","OPEN_CELL","openCell","didWin","RIGHT_CLICK_CELL","recalculateHiddenMines","toggleFlagCell","CHANGE_LEVEL","GAME_OVER","Error","rows","columns","Array","from","fill","hasMine","isOpen","countMinesAround","hasFlag","boardWithSeedMines","seedMine","seedNumber","blankBoard","numMineToSeed","totalSeedMines","tempBoard","JSON","parse","stringify","rowIndex","neighborsPosition","map","index","i","length","includes","luckyNumber","Math","floor","random","prevBoard","j","neighborsStatus","minesAround","forEach","neighbor","cell","originalBoard","newBoard","openNeighbors","row","column","console","log","memo","stack","centerCell","pop","surroundingCells","flagsInAdjacentCells","reduce","acc","currCell","push"],"mappings":"AAAA,SAASA,cAAT,QAA+B,4BAA/B,C,CACA;;AACA,OAAOC,WAAP,MAAwB,wBAAxB;AACA,SAASC,kBAAT,EAA6BC,oBAA7B,QAAyD,oBAAzD;AAEA,OAAO,SAASC,YAAT,CAAsBC,KAAtB,EAA6B;AAAEC,EAAAA,IAAF;AAAQC,EAAAA;AAAR,CAA7B,EAAgD;AACrD,UAAQD,IAAR;AACE,SAAKL,WAAW,CAACO,kBAAjB;AACE,aAAO,EACL,GAAGH,KADE;AAELI,QAAAA,QAAQ,EAAE,KAFL;AAGLC,QAAAA,MAAM,EAAE,KAHH;AAILC,QAAAA,SAAS,EAAE,KAJN;AAKLC,QAAAA,WAAW,EAAEP,KAAK,CAACQ,KAAN,CAAYC,UALpB;AAMLC,QAAAA,KAAK,EAAEC,aAAa,CAACX,KAAK,CAACQ,KAAP;AANf,OAAP;;AASF,SAAKZ,WAAW,CAACgB,yBAAjB;AACE,aAAO,EACL,GAAGZ,KADE;AAELO,QAAAA,WAAW,EAAEL,OAAO,CAACM,KAAR,CAAcC,UAFtB;AAGLC,QAAAA,KAAK,EAAEG,mBAAmB,CAACb,KAAK,CAACU,KAAP,EAAcR,OAAO,CAACM,KAAtB,EAA6BN,OAAO,CAACY,SAArC,EAAgDZ,OAAO,CAACa,SAAxD,CAHrB;AAILT,QAAAA,SAAS,EAAE;AAJN,OAAP;;AAOF,SAAKV,WAAW,CAACoB,SAAjB;AACE,aAAO,EACL,GAAGhB,KADE;AAELU,QAAAA,KAAK,EAAEO,QAAQ,CAACjB,KAAK,CAACU,KAAP,EAAcR,OAAO,CAACY,SAAtB,EAAiCZ,OAAO,CAACa,SAAzC,CAFV;AAGLV,QAAAA,MAAM,EAAEa,MAAM,CAACD,QAAQ,CAACjB,KAAK,CAACU,KAAP,EAAcR,OAAO,CAACY,SAAtB,EAAiCZ,OAAO,CAACa,SAAzC,CAAT;AAHT,OAAP;AAMF;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAKnB,WAAW,CAACuB,gBAAjB;AACE,aAAO,EACL,GAAGnB,KADE;AAELO,QAAAA,WAAW,EAAEa,sBAAsB,CAACpB,KAAK,CAACU,KAAP,EAAcR,OAAO,CAACY,SAAtB,EAAiCZ,OAAO,CAACa,SAAzC,EAAoDf,KAAK,CAACO,WAA1D,CAF9B;AAGLG,QAAAA,KAAK,EAAEW,cAAc,CAACrB,KAAK,CAACU,KAAP,EAAcR,OAAO,CAACY,SAAtB,EAAiCZ,OAAO,CAACa,SAAzC,CAHhB;AAILV,QAAAA,MAAM,EAAEa,MAAM,CAACG,cAAc,CAACrB,KAAK,CAACU,KAAP,EAAcR,OAAO,CAACY,SAAtB,EAAiCZ,OAAO,CAACa,SAAzC,CAAf;AAJT,OAAP;;AAOF,SAAKnB,WAAW,CAAC0B,YAAjB;AACE,aAAO,EACL,GAAGtB,KADE;AAELI,QAAAA,QAAQ,EAAE,KAFL;AAGLC,QAAAA,MAAM,EAAE,KAHH;AAILC,QAAAA,SAAS,EAAE,KAJN;AAKLE,QAAAA,KAAK,EAAEN,OAAO,CAACM,KALV;AAMLD,QAAAA,WAAW,EAAEL,OAAO,CAACM,KAAR,CAAcC,UANtB;AAOLC,QAAAA,KAAK,EAAEC,aAAa,CAACT,OAAO,CAACM,KAAT;AAPf,OAAP;;AAUF,SAAKZ,WAAW,CAAC2B,SAAjB;AACE,aAAO,EACL,GAAGvB,KADE;AAELI,QAAAA,QAAQ,EAAE;AAFL,OAAP;;AAKF;AACE,YAAM,IAAIoB,KAAJ,CAAU,oCAAV,CAAN;AA3DJ;AA6DD;;AAoBD,SAASb,aAAT,CAAuB;AAAEc,EAAAA,IAAF;AAAQC,EAAAA;AAAR,CAAvB,EAA0C;AACxC,SAAOC,KAAK,CAACC,IAAN,CACLD,KAAK,CAACF,IAAD,CADA,EACQ,MACb,IAAIE,KAAJ,CAAUD,OAAV,EAAmBG,IAAnB,CAAwB;AACtBC,IAAAA,OAAO,EAAE,KADa;AAEtBC,IAAAA,MAAM,EAAE,KAFc;AAGtBC,IAAAA,gBAAgB,EAAE,CAHI;AAItBC,IAAAA,OAAO,EAAE;AAJa,GAAxB,CAFK,CAAP;AASD;;AAED,SAASpB,mBAAT,CAA6BH,KAA7B,EAAoCF,KAApC,EAA2CM,SAA3C,EAAsDC,SAAtD,EAAiE;AAC/D,MAAImB,kBAAkB,GAAGC,QAAQ,CAACzB,KAAD,EAAQF,KAAK,CAACC,UAAd,EAA0BK,SAA1B,EAAqCC,SAArC,CAAjC;AACA,SAAOqB,UAAU,CAACF,kBAAD,CAAjB,CAF+D,CAEzB;AACvC;;AAED,SAASC,QAAT,CAAkBE,UAAlB,EAA8BC,aAA9B,EAA6CxB,SAA7C,EAAwDC,SAAxD,EAAmE;AACjE,MAAIwB,cAAc,GAAG,CAArB,CADiE,CACzC;;AACxB,MAAIC,SAAS,GAAGC,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,SAAL,CAAeN,UAAf,CAAX,CAAhB;AAGA,MAAIO,QAAQ,GAAG,CAAf;AAEA,QAAMC,iBAAiB,GAAG/C,oBAAoB,CAACgB,SAAD,EAAYC,SAAZ,CAApB,CAA2C+B,GAA3C,CAA+CC,KAAK,IAAIN,IAAI,CAACE,SAAL,CAAeI,KAAf,CAAxD,CAA1B;;AAEA,SAAOR,cAAc,GAAGD,aAAxB,EAAuC;AACrC,SAAK,IAAIU,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGX,UAAU,CAACO,QAAD,CAAV,CAAqBK,MAAzC,EAAiDD,CAAC,EAAlD,EAAsD;AAEpD,UAAIT,cAAc,KAAKD,aAAvB,EAAsC;AACtC,UAAIM,QAAQ,KAAK9B,SAAb,IAA0BkC,CAAC,KAAKjC,SAApC,EAA+C;AAC/C,UAAI8B,iBAAiB,CAACK,QAAlB,CAA2BT,IAAI,CAACE,SAAL,CAAe,CAACC,QAAD,EAAWI,CAAX,CAAf,CAA3B,CAAJ,EAA+D;AAE/D,YAAMG,WAAW,GAAGC,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,MAAL,KAAgBF,IAAI,CAACC,KAAL,CAAW,EAAX,CAA3B,CAApB;;AACA,UAAIF,WAAW,KAAK,CAAhB,IAAqBX,SAAS,CAACI,QAAD,CAAT,CAAoBI,CAApB,EAAuBlB,OAAvB,KAAmC,KAA5D,EAAmE;AACjEU,QAAAA,SAAS,CAACI,QAAD,CAAT,CAAoBI,CAApB,EAAuBlB,OAAvB,GAAiC,IAAjC;AACAS,QAAAA,cAAc;AACf;AACF;;AAAA;AACD,QAAIK,QAAQ,KAAKP,UAAU,CAACY,MAAX,GAAoB,CAArC,EAAwCL,QAAQ,GAAG,CAAX,CAAxC,KACKA,QAAQ;AACd;;AACD,SAAOJ,SAAP;AACD;;AAED,SAASJ,UAAT,CAAoBmB,SAApB,EAA+B;AAC7B,OAAK,IAAIP,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGO,SAAS,CAACN,MAA9B,EAAsCD,CAAC,EAAvC,EAA2C;AACzC,SAAK,IAAIQ,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,SAAS,CAACP,CAAD,CAAT,CAAaC,MAAjC,EAAyCO,CAAC,EAA1C,EAA8C;AAC5C,YAAMC,eAAe,GAAG5D,kBAAkB,CAAC0D,SAAD,EAAYP,CAAZ,EAAeQ,CAAf,CAA1C;AACA,UAAIE,WAAW,GAAG,CAAlB;AACAD,MAAAA,eAAe,CAACE,OAAhB,CAAyBC,QAAD,IAAc;AAAC;AACrC,YAAIA,QAAQ,CAACC,IAAT,CAAc/B,OAAlB,EAA2B4B,WAAW;AACvC,OAFD;AAIAH,MAAAA,SAAS,CAACP,CAAD,CAAT,CAAaQ,CAAb,EAAgBxB,gBAAhB,GAAmC0B,WAAnC;AACD;AACF;;AACD,SAAOH,SAAP;AACD;;AAAA;;AAED,SAAStC,QAAT,CAAkB6C,aAAlB,EAAiChD,SAAjC,EAA4CC,SAA5C,EAAuD;AACrD,QAAMgD,QAAQ,GAAGtB,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,SAAL,CAAemB,aAAf,CAAX,CAAjB;AACAC,EAAAA,QAAQ,CAACjD,SAAD,CAAR,CAAoBC,SAApB,EAA+BgB,MAA/B,GAAwC,IAAxC;;AACA,MAAIgC,QAAQ,CAACjD,SAAD,CAAR,CAAoBC,SAApB,EAA+BiB,gBAA/B,KAAoD,CAApD,IAAyD,CAAC+B,QAAQ,CAACjD,SAAD,CAAR,CAAoBC,SAApB,EAA+Be,OAA7F,EAAsG;AACpG,WAAOkC,aAAa,CAACD,QAAD,EAAWjD,SAAX,EAAsBC,SAAtB,CAApB;AACD;;AACD,SAAOgD,QAAP;AACD;;AAED,SAASC,aAAT,CAAuBF,aAAvB,EAAsCG,GAAtC,EAA2CC,MAA3C,EAAmD;AACjDC,EAAAA,OAAO,CAACC,GAAR,CAAY,WAAZ,EAAyBN,aAAa,CAACG,GAAD,CAAb,CAAmBC,MAAnB,CAAzB;AAEA,QAAMG,IAAI,GAAG,EAAb;AACA,QAAMC,KAAK,GAAG,CAAC;AAAET,IAAAA,IAAI,EAAEC,aAAa,CAACG,GAAD,CAAb,CAAmBC,MAAnB,CAAR;AAAoCD,IAAAA,GAApC;AAAyCC,IAAAA;AAAzC,GAAD,CAAd,CAJiD,CAKjD;;AAEA,SAAOI,KAAK,CAACrB,MAAN,GAAe,CAAtB,EAAyB;AACvB,UAAMsB,UAAU,GAAGD,KAAK,CAACE,GAAN,EAAnB;AACA,UAAMC,gBAAgB,GAAG5E,kBAAkB,CAACiE,aAAD,EAAgBS,UAAU,CAACN,GAA3B,EAAgCM,UAAU,CAACL,MAA3C,CAA3C;AAEA,UAAMQ,oBAAoB,GAAGD,gBAAgB,CAACE,MAAjB,CAAwB,CAACC,GAAD,EAAMC,QAAN,KAAmB;AACtE,UAAIA,QAAQ,CAAChB,IAAT,CAAc5B,OAAlB,EAA2B,OAAO2C,GAAG,GAAG,CAAb;AAC3B,aAAOA,GAAP;AACD,KAH4B,EAG1B,CAH0B,CAA7B;AAKA,QAAIF,oBAAoB,GAAGH,UAAU,CAACV,IAAX,CAAgB7B,gBAA3C,EAA6D,OAAO8B,aAAP;;AAE7D,SAAK,IAAID,IAAT,IAAiBY,gBAAjB,EAAmC;AACjC,UAAIJ,IAAI,CAAE,GAAER,IAAI,CAACI,GAAI,IAAGJ,IAAI,CAACK,MAAO,EAA5B,CAAR,EAAwC,SAAxC,KACK;AACHG,QAAAA,IAAI,CAAE,GAAER,IAAI,CAACI,GAAI,IAAGJ,IAAI,CAACK,MAAO,EAA5B,CAAJ,GAAqC,IAArC;AACD;AAEDL,MAAAA,IAAI,CAACA,IAAL,CAAU9B,MAAV,GAAmB8B,IAAI,CAACA,IAAL,CAAU5B,OAAV,GAAoB,KAApB,GAA4B,IAA/C;;AAEA,UAAI4B,IAAI,CAACA,IAAL,IAAa,CAACA,IAAI,CAACA,IAAL,CAAU7B,gBAAxB,IAA4C,CAAC6B,IAAI,CAACA,IAAL,CAAU/B,OAA3D,EAAoE;AAClEwC,QAAAA,KAAK,CAACQ,IAAN,CAAWjB,IAAX;AACD;AACF;AACF;;AAED,SAAOC,aAAP;AACD;;AAAA;;AAoBD,SAAS1C,sBAAT,CAAgCV,KAAhC,EAAuCuD,GAAvC,EAA4CC,MAA5C,EAAoD3D,WAApD,EAAiE;AAC/D,SAAOG,KAAK,CAACuD,GAAD,CAAL,CAAWC,MAAX,EAAmBjC,OAAnB,GAA6B1B,WAAW,GAAG,CAA3C,GAA+CA,WAAW,GAAG,CAApE;AACD,C,CAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,SAASc,cAAT,CAAwByC,aAAxB,EAAuCG,GAAvC,EAA4CC,MAA5C,EAAoD;AAClD,QAAMH,QAAQ,GAAGtB,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,SAAL,CAAemB,aAAf,CAAX,CAAjB;AACAC,EAAAA,QAAQ,CAACE,GAAD,CAAR,CAAcC,MAAd,EAAsBjC,OAAtB,GAAgC,CAAC8B,QAAQ,CAACE,GAAD,CAAR,CAAcC,MAAd,EAAsBjC,OAAvD;AACA,SAAO8B,QAAP;AACD;;AAID,SAAS7C,MAAT,CAAgBR,KAAhB,EAAuB;AACrB,OAAK,IAAIsC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGtC,KAAK,CAACuC,MAA1B,EAAkCD,CAAC,EAAnC,EAAuC;AACrC,SAAK,IAAIQ,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG9C,KAAK,CAAC,CAAD,CAAL,CAASuC,MAA7B,EAAqCO,CAAC,EAAtC,EAA0C;AACxC,UAAI,CAAC9C,KAAK,CAACsC,CAAD,CAAL,CAASQ,CAAT,EAAY1B,OAAb,IAAwB,CAACpB,KAAK,CAACsC,CAAD,CAAL,CAASQ,CAAT,EAAYzB,MAAzC,EAAiD;AAC/C,eAAO,KAAP;AACD;;AAED,UAAI,CAACrB,KAAK,CAACsC,CAAD,CAAL,CAASQ,CAAT,EAAY1B,OAAb,IAAwBpB,KAAK,CAACsC,CAAD,CAAL,CAASQ,CAAT,EAAYvB,OAAxC,EAAiD;AAC/C,eAAO,KAAP;AACD;AACF;AACF;;AACD,SAAO,IAAP;AACD","sourcesContent":["import { InjectMineEnum } from '../constants/gameConstants';\n//import { BoardActions } from '../actions/BoardActions';\nimport actionsName from \"../actions/actionsName\"\nimport { getNeighborsStatus, getNeighborsPosition } from '../utility/utility';\n\nexport function boardReducer(state, { type, payload }) {\n  switch (type) {\n    case actionsName.CREATE_BLANK_BOARD:\n      return {\n        ...state,\n        gameOver: false,\n        winner: false,\n        isStarted: false,\n        hiddenMines: state.level.totalMines,\n        board: setBlankBoard(state.level),\n      };\n\n    case actionsName.CREATE_STARTED_GAME_BOARD:\n      return {\n        ...state,\n        hiddenMines: payload.level.totalMines,\n        board: seedMinesAndNumbers(state.board, payload.level, payload.positionX, payload.positionY),\n        isStarted: true,\n      };\n\n    case actionsName.OPEN_CELL:\n      return {\n        ...state,\n        board: openCell(state.board, payload.positionX, payload.positionY),\n        winner: didWin(openCell(state.board, payload.positionX, payload.positionY)),\n      };\n\n    // case actionsName.DOUBLE_CLICK_CELL:\n    //   return {\n    //     ...state,\n    //     board: uncoverAdjacentCells(state.board, payload.row, payload.column),\n    //     winner: didWin(uncoverAdjacentCells(state.board, payload.row, payload.column)),\n    //   };\n\n    case actionsName.RIGHT_CLICK_CELL:\n      return {\n        ...state,\n        hiddenMines: recalculateHiddenMines(state.board, payload.positionX, payload.positionY, state.hiddenMines),\n        board: toggleFlagCell(state.board, payload.positionX, payload.positionY),\n        winner: didWin(toggleFlagCell(state.board, payload.positionX, payload.positionY)),\n      };\n\n    case actionsName.CHANGE_LEVEL:\n      return {\n        ...state,\n        gameOver: false,\n        winner: false,\n        isStarted: false,\n        level: payload.level,\n        hiddenMines: payload.level.totalMines,\n        board: setBlankBoard(payload.level),\n      };\n\n    case actionsName.GAME_OVER:\n      return {\n        ...state,\n        gameOver: true,\n      };\n\n    default:\n      throw new Error('No matching action type in reducer');\n  }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction setBlankBoard({ rows, columns }) {\n  return Array.from(\n    Array(rows), () =>\n    new Array(columns).fill({\n      hasMine: false,\n      isOpen: false,\n      countMinesAround: 0,\n      hasFlag: false,\n    })\n  );\n}\n\nfunction seedMinesAndNumbers(board, level, positionX, positionY) {\n  let boardWithSeedMines = seedMine(board, level.totalMines, positionX, positionY);\n  return seedNumber(boardWithSeedMines);//, positionX, positionY\n}\n\nfunction seedMine(blankBoard, numMineToSeed, positionX, positionY) {\n  let totalSeedMines = 0; //numInjectedMines\n  let tempBoard = JSON.parse(JSON.stringify(blankBoard));\n\n\n  let rowIndex = 0;\n\n  const neighborsPosition = getNeighborsPosition(positionX, positionY).map(index => JSON.stringify(index));\n\n  while (totalSeedMines < numMineToSeed) {\n    for (let i = 0; i < blankBoard[rowIndex].length; i++) {\n\n      if (totalSeedMines === numMineToSeed) break;\n      if (rowIndex === positionX && i === positionY) continue;\n      if (neighborsPosition.includes(JSON.stringify([rowIndex, i]))) continue;\n\n      const luckyNumber = Math.floor(Math.random() * Math.floor(10));\n      if (luckyNumber === 1 && tempBoard[rowIndex][i].hasMine === false) {\n        tempBoard[rowIndex][i].hasMine = true;\n        totalSeedMines++;\n      }\n    };\n    if (rowIndex === blankBoard.length - 1) rowIndex = 0;\n    else rowIndex++;\n  }\n  return tempBoard;\n}\n\nfunction seedNumber(prevBoard) {\n  for (let i = 0; i < prevBoard.length; i++) {\n    for (let j = 0; j < prevBoard[i].length; j++) {\n      const neighborsStatus = getNeighborsStatus(prevBoard, i, j);\n      let minesAround = 0;\n      neighborsStatus.forEach((neighbor) => {//, row, column\n        if (neighbor.cell.hasMine) minesAround++;\n      })\n\n      prevBoard[i][j].countMinesAround = minesAround;\n    }\n  }\n  return prevBoard;\n};\n\nfunction openCell(originalBoard, positionX, positionY) {\n  const newBoard = JSON.parse(JSON.stringify(originalBoard));\n  newBoard[positionX][positionY].isOpen = true;\n  if (newBoard[positionX][positionY].countMinesAround === 0 && !newBoard[positionX][positionY].hasMine) {\n    return openNeighbors(newBoard, positionX, positionY);\n  }\n  return newBoard;\n}\n\nfunction openNeighbors(originalBoard, row, column) {\n  console.log(\"staaaaack\", originalBoard[row][column])\n\n  const memo = {};\n  const stack = [{ cell: originalBoard[row][column], row, column }];\n  // console.log(\"staaaaack\", stack)\n\n  while (stack.length > 0) {\n    const centerCell = stack.pop();\n    const surroundingCells = getNeighborsStatus(originalBoard, centerCell.row, centerCell.column);\n\n    const flagsInAdjacentCells = surroundingCells.reduce((acc, currCell) => {\n      if (currCell.cell.hasFlag) return acc + 1;\n      return acc;\n    }, 0);\n\n    if (flagsInAdjacentCells < centerCell.cell.countMinesAround) return originalBoard;\n\n    for (let cell of surroundingCells) {\n      if (memo[`${cell.row}-${cell.column}`]) continue;\n      else {\n        memo[`${cell.row}-${cell.column}`] = true;\n      }\n\n      cell.cell.isOpen = cell.cell.hasFlag ? false : true;\n\n      if (cell.cell && !cell.cell.countMinesAround && !cell.cell.hasMine) {\n        stack.push(cell);\n      }\n    }\n  }\n\n  return originalBoard;\n};\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction recalculateHiddenMines(board, row, column, hiddenMines) {\n  return board[row][column].hasFlag ? hiddenMines + 1 : hiddenMines - 1\n}\n\n// function uncoverCell(originalBoard, positionX, positionY) {\n//   const newBoard = JSON.parse(JSON.stringify(originalBoard));\n//   newBoard[positionX][positionY].isOpen = true;\n//   if (newBoard[positionX][positionY].countMinesAround === 0 && !newBoard[positionX][positionY].hasMine) {\n//     return uncoverAdjacentCells(newBoard, positionX, positionY);\n//   }\n//   return newBoard;\n// }\n\nfunction toggleFlagCell(originalBoard, row, column) {\n  const newBoard = JSON.parse(JSON.stringify(originalBoard));\n  newBoard[row][column].hasFlag = !newBoard[row][column].hasFlag;\n  return newBoard\n}\n\n\n\nfunction didWin(board) {\n  for (let i = 0; i < board.length; i++) {\n    for (let j = 0; j < board[0].length; j++) {\n      if (!board[i][j].hasMine && !board[i][j].isOpen) {\n        return false;\n      }\n\n      if (!board[i][j].hasMine && board[i][j].hasFlag) {\n        return false;\n      }\n    }\n  }\n  return true;\n}"]},"metadata":{},"sourceType":"module"}